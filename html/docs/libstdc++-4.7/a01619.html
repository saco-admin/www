<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: Non-Mutating</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a01619.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Non-Mutating</div>  </div>
<div class="ingroups"><a class="el" href="a01617.html">Algorithms</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Non-Mutating:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a01619.png" border="0" alt="" usemap="#a01619"/>
<map name="a01619" id="a01619">
<area shape="rect" id="node2" href="a01617.html" title="Algorithms" alt="" coords="5,5,93,33"/></map>
</td></tr></table></center>
</div>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>template&lt;typename _ForwardIterator &gt; _ForwardIterator <a class="el" href="a01619.html#ga094e6f312833388e6a97159b5d2c4177">std::adjacent_find</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; _ForwardIterator <a class="el" href="a01619.html#ga29b281099618951de1ab1315ac9e7737">std::adjacent_find</a> (_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; bool <a class="el" href="a01619.html#gaaef2d0f2f0d6942636f6f42eb940b850">std::all_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; bool <a class="el" href="a01619.html#gaa8fada47994395ec51bb54536d6a87f9">std::any_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _InputIterator , typename _Tp &gt; iterator_traits<br class="typebreak"/>
&lt; _InputIterator &gt;<br class="typebreak"/>
::difference_type <a class="el" href="a01619.html#gad2f89a1340c43c8451e522d045aaa1b6">std::count</a> (_InputIterator __first, _InputIterator __last, const _Tp &amp;__value)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; iterator_traits<br class="typebreak"/>
&lt; _InputIterator &gt;<br class="typebreak"/>
::difference_type <a class="el" href="a01619.html#gab17add9e8922a4e8a9893d0d094f5e4e">std::count_if</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; bool <a class="el" href="a01619.html#ga444f163947d0a55953d1c317b31aee89">std::equal</a> (_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)
<li>template&lt;typename _II1 , typename _II2 &gt; bool <a class="el" href="a01619.html#gad9f16258cd8b86bb63165c004cf660d5">std::equal</a> (_II1 __first1, _II1 __last1, _II2 __first2)
<li>template&lt;typename _InputIterator , typename _Tp &gt; _InputIterator <a class="el" href="a01619.html#ga346cc7c0b794d9a487a11b44b6b238ab">std::find</a> (_InputIterator __first, _InputIterator __last, const _Tp &amp;__val)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; _ForwardIterator1 <a class="el" href="a01619.html#gaf97d3d3c35f24541246e9d222fd45d44">std::find_end</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; _ForwardIterator1 <a class="el" href="a01619.html#gac12e9d93b9b26024222cc645d2a4a8d5">std::find_end</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)
<li>template&lt;typename _InputIterator , typename _ForwardIterator &gt; _InputIterator <a class="el" href="a01619.html#ga5f2c547c925b080c25f17765a755a0cb">std::find_first_of</a> (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)
<li>template&lt;typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate &gt; _InputIterator <a class="el" href="a01619.html#ga4f6564022032cfc6ea5c24b6dce5b4a7">std::find_first_of</a> (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; _InputIterator <a class="el" href="a01619.html#gaaf6e9995ebbd27994d7c73b375f86088">std::find_if</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; _InputIterator <a class="el" href="a01619.html#gaa0bfffb70439c7d2cab9e917e8d604a6">std::find_if_not</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _InputIterator , typename _Function &gt; _Function <a class="el" href="a01619.html#ga36d3b88a382b4ad3bf55aff3f597522d">std::for_each</a> (_InputIterator __first, _InputIterator __last, _Function __f)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; bool <a class="el" href="a01619.html#gadc446c7587539490a05da590d6c51a58">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; bool <a class="el" href="a01619.html#ga714d45aee3d18a5e281557b48d092b8e">std::is_permutation</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; pair&lt; _InputIterator1, <br class="typebreak"/>
_InputIterator2 &gt; <a class="el" href="a01619.html#ga44ee120346d18fb398be3891eb4a8c0c">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; pair&lt; _InputIterator1, <br class="typebreak"/>
_InputIterator2 &gt; <a class="el" href="a01619.html#gad3cb7460f4803c1073882c89456bb75c">std::mismatch</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; bool <a class="el" href="a01619.html#ga245f9003d26e4ca6c9b304c4cca2c77f">std::none_of</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; _ForwardIterator1 <a class="el" href="a01619.html#ga37e40c12374da3b76f2af5d2025b3018">std::search</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; _ForwardIterator1 <a class="el" href="a01619.html#gab76055789d1a598394f609cf19724220">std::search</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)
<li>template&lt;typename _ForwardIterator , typename _Integer , typename _Tp &gt; _ForwardIterator <a class="el" href="a01619.html#ga98baadb721fcb143396118e3a678cd0e">std::search_n</a> (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val)
<li>template&lt;typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate &gt; _ForwardIterator <a class="el" href="a01619.html#ga4fd2241c480f56cb4fef2ae7da4d36b0">std::search_n</a> (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val, _BinaryPredicate __binary_pred)
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga094e6f312833388e6a97159b5d2c4177"></a><!-- doxytag: member="std::adjacent_find" ref="ga094e6f312833388e6a97159b5d2c4177" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find two adjacent values in a sequence that are equal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>*i</code> == <code>*</code>(i+1), or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04583">4583</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga29b281099618951de1ab1315ac9e7737"></a><!-- doxytag: member="std::adjacent_find" ref="ga29b281099618951de1ab1315ac9e7737" args="(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::adjacent_find </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find two adjacent values in a sequence using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> such that <code>i</code> and <code>i+1</code> are both valid iterators in <code></code>[__first,__last) and such that <code>__binary_pred</code>(*i,*(i+1)) is true, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04615">4615</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaef2d0f2f0d6942636f6f42eb940b850"></a><!-- doxytag: member="std::all_of" ref="gaaef2d0f2f0d6942636f6f42eb940b850" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::all_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that a predicate is true for all the elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if <code>__pred</code> is true for each element in the range <code></code>[__first,__last), and false otherwise. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00755">755</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00805">std::find_if_not()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa8fada47994395ec51bb54536d6a87f9"></a><!-- doxytag: member="std::any_of" ref="gaa8fada47994395ec51bb54536d6a87f9" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::any_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that a predicate is false for at least an element of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if an element exists in the range <code></code>[__first,__last) such that <code>__pred</code> is true, and false otherwise. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00790">790</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00772">std::none_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gad2f89a1340c43c8451e522d045aaa1b6"></a><!-- doxytag: member="std::count" ref="gad2f89a1340c43c8451e522d045aaa1b6" args="(_InputIterator __first, _InputIterator __last, const _Tp &amp;__value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator_traits&lt;_InputIterator&gt;::difference_type <a class="el" href="a01576.html#ac58e3291b25d9f423330a8983004a8f6">std::count</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the number of copies of a value in a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be counted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>*i</code> == <code>__value</code> </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04647">4647</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab17add9e8922a4e8a9893d0d094f5e4e"></a><!-- doxytag: member="std::count_if" ref="gab17add9e8922a4e8a9893d0d094f5e4e" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator_traits&lt;_InputIterator&gt;::difference_type std::count_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Count the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of iterators <code>i</code> in the range <code></code>[__first,__last) for which <code>__pred(*i)</code> is true. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04672">4672</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l04342">std::is_permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="ga444f163947d0a55953d1c317b31aee89"></a><!-- doxytag: member="std::equal" ref="ga444f163947d0a55953d1c317b31aee89" args="(_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _IIter1 , typename _IIter2 , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_IIter2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01629.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l01055">1055</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad9f16258cd8b86bb63165c004cf660d5"></a><!-- doxytag: member="std::equal" ref="gad9f16258cd8b86bb63165c004cf660d5" args="(_II1 __first1, _II1 __last1, _II2 __first2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::equal </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tests a range for element-wise equality. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean true or false.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns true or false depending on whether all of the corresponding elements of the ranges are equal. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l01023">1023</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

<p>Referenced by <a class="el" href="a01382_source.html#l01848">std::operator==()</a>.</p>

</div>
</div>
<a class="anchor" id="ga346cc7c0b794d9a487a11b44b6b238ab"></a><!-- doxytag: member="std::find" ref="ga346cc7c0b794d9a487a11b44b6b238ab" args="(_InputIterator __first, _InputIterator __last, const _Tp &amp;__val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the first occurrence of a value in a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>*i</code> == <code>__val</code>, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04457">4457</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00132">std::__find()</a>, and <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf97d3d3c35f24541246e9d222fd45d44"></a><!-- doxytag: member="std::find_end" ref="gaf97d3d3c35f24541246e9d222fd45d44" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::find_end </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find last matching subsequence in a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the __first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00673">673</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="gac12e9d93b9b26024222cc645d2a4a8d5"></a><!-- doxytag: member="std::find_end" ref="gac12e9d93b9b26024222cc645d2a4a8d5" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::find_end </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find last matching subsequence in a sequence using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence to match. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence to match. </td></tr>
    <tr><td class="paramname">__comp</td><td>The predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>predicate</code>(*(i+N), <code></code>(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) using comp as a predicate and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found. The sub-sequence will be the last such subsequence contained in [__first,__last1).</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence. This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00721">721</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5f2c547c925b080c25f17765a755a0cb"></a><!-- doxytag: member="std::find_first_of" ref="ga5f2c547c925b080c25f17765a755a0cb" args="(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_first_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find element from a set in a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>*i</code> == <code>*</code>(i2) such that i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04511">4511</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f6564022032cfc6ea5c24b6dce5b4a7"></a><!-- doxytag: member="std::find_first_of" ref="ga4f6564022032cfc6ea5c24b6dce5b4a7" args="(_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_first_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find element from a set in a sequence using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of range to search. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of range to search. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of match candidates. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of match candidates. </td></tr>
    <tr><td class="paramname">__comp</td><td>Predicate to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1) such that <code>comp</code>(*i, <code>*</code>(i2)) is true and i2 is an iterator in [__first2,__last2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for an element that is equal to some element in the range [__first2,__last2). If found, returns an iterator in the range [__first1,__last1), otherwise returns <code>__last1</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04552">4552</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf6e9995ebbd27994d7c73b375f86088"></a><!-- doxytag: member="std::find_if" ref="gaaf6e9995ebbd27994d7c73b375f86088" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the first element in a sequence for which a predicate is true. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is true, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04481">4481</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00143">std::__find_if()</a>, and <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0bfffb70439c7d2cab9e917e8d604a6"></a><!-- doxytag: member="std::find_if_not" ref="gaa0bfffb70439c7d2cab9e917e8d604a6" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_InputIterator std::find_if_not </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the first element in a sequence for which a predicate is false. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last) such that <code>__pred(*i)</code> is false, or <code>__last</code> if no such iterator exists. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l00805">805</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00250">std::__find_if_not()</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l00755">std::all_of()</a>, and <a class="el" href="a01462_source.html#l00828">std::is_partitioned()</a>.</p>

</div>
</div>
<a class="anchor" id="ga36d3b88a382b4ad3bf55aff3f597522d"></a><!-- doxytag: member="std::for_each" ref="ga36d3b88a382b4ad3bf55aff3f597522d" args="(_InputIterator __first, _InputIterator __last, _Function __f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Function std::for_each </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Function&#160;</td>
          <td class="paramname"><em>__f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Apply a function to every element of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__f</td><td>A unary function object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>__f</code> (std::move(<code>__f</code>) in C++0x).</dd></dl>
<p>Applies the function object <code>__f</code> to each element in the range <code></code>[first,last). <code>__f</code> must not modify the order of the sequence. If <code>__f</code> has a return value it is ignored. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04436">4436</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gadc446c7587539490a05da590d6c51a58"></a><!-- doxytag: member="std::is_permutation" ref="gadc446c7587539490a05da590d6c51a58" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a permutaion of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there exists a permutation of the elements in the range [__first2, __first2 + (__last1 - __first1)), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, begin) returns true; otherwise, returns false. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04296">4296</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01470_source.html#l00172">std::advance()</a>, <a class="el" href="a00978_source.html#l01279">std::count()</a>, and <a class="el" href="a01470_source.html#l00114">std::distance()</a>.</p>

</div>
</div>
<a class="anchor" id="ga714d45aee3d18a5e281557b48d092b8e"></a><!-- doxytag: member="std::is_permutation" ref="ga714d45aee3d18a5e281557b48d092b8e" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _BinaryPredicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_permutation </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether a permutation of the second sequence is equal to the first sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there exists a permutation of the elements in the range [__first2, __first2 + (__last1 - __first1)), beginning with ForwardIterator2 begin, such that equal(__first1, __last1, __begin, __pred) returns true; otherwise, returns false. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04342">4342</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01470_source.html#l00172">std::advance()</a>, <a class="el" href="a01173_source.html#l01521">std::bind()</a>, <a class="el" href="a01462_source.html#l04672">std::count_if()</a>, and <a class="el" href="a01470_source.html#l00114">std::distance()</a>.</p>

</div>
</div>
<a class="anchor" id="ga44ee120346d18fb398be3891eb4a8c0c"></a><!-- doxytag: member="std::mismatch" ref="ga44ee120346d18fb398be3891eb4a8c0c" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using <code>==</code> and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l01160">1160</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad3cb7460f4803c1073882c89456bb75c"></a><!-- doxytag: member="std::mismatch" ref="gad3cb7460f4803c1073882c89456bb75c" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_InputIterator1, _InputIterator2&gt; std::mismatch </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the places in ranges which don't match. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate <a class="el" href="a01629.html">functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair of iterators pointing to the first mismatch.</dd></dl>
<p>This compares the elements of two ranges using the binary_pred parameter, and returns a pair of iterators. The first iterator points into the first range, the second iterator points into the second range, and the elements pointed to by the iterators are not equal. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l01198">1198</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga245f9003d26e4ca6c9b304c4cca2c77f"></a><!-- doxytag: member="std::none_of" ref="ga245f9003d26e4ca6c9b304c4cca2c77f" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::none_of </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks that a predicate is false for all the elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check is true, false otherwise.</dd></dl>
<p>Returns true if <code>__pred</code> is false for each element in the range <code></code>[__first,__last), and false otherwise. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00772">772</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l00790">std::any_of()</a>, and <a class="el" href="a01462_source.html#l00828">std::is_partitioned()</a>.</p>

</div>
</div>
<a class="anchor" id="ga37e40c12374da3b76f2af5d2025b3018"></a><!-- doxytag: member="std::search" ref="ga37e40c12374da3b76f2af5d2025b3018" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search a sequence for a matching sub-sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>*</code>(i+N) == <code>*</code>(__first2+N) for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2) and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if the sub-sequence is not found.</p>
<p>Because the sub-sequence must lie completely within the range <code></code>[__first1,__last1) it must start at a position less than <code>__last1-</code>(__last2-__first2) where <code>__last2-__first2</code> is the length of the sub-sequence.</p>
<p>This means that the returned iterator <code>i</code> will be in the range <code></code>[__first1,__last1-(__last2-__first2)) </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04714">4714</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab76055789d1a598394f609cf19724220"></a><!-- doxytag: member="std::search" ref="gab76055789d1a598394f609cf19724220" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator1 std::search </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search a sequence for a matching sub-sequence using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__predicate</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first1,__last1-(__last2-__first2)) such that <code>__predicate</code>(*(i+N),*(__first2+N)) is true for each <code>N</code> in the range <code></code>[0,__last2-__first2), or <code>__last1</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first1,__last1) for a sub-sequence that compares equal value-by-value with the sequence given by <code></code>[__first2,__last2), using <code>__predicate</code> to determine equality, and returns an iterator to the first element of the sub-sequence, or <code>__last1</code> if no such iterator exists.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2) </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04786">4786</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga98baadb721fcb143396118e3a678cd0e"></a><!-- doxytag: member="std::search_n" ref="ga98baadb721fcb143396118e3a678cd0e" args="(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Integer , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer&#160;</td>
          <td class="paramname"><em>__count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search a sequence for a number of consecutive values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>*</code>(i+N) == <code>__val</code> for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>count</code> consecutive elements equal to <code>__val</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04860">4860</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>, and <a class="el" href="a01462_source.html#l00349">std::__search_n()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4fd2241c480f56cb4fef2ae7da4d36b0"></a><!-- doxytag: member="std::search_n" ref="ga4fd2241c480f56cb4fef2ae7da4d36b0" args="(_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &amp;__val, _BinaryPredicate __binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::search_n </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Integer&#160;</td>
          <td class="paramname"><em>__count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search a sequence for a number of consecutive values using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__count</td><td>The number of consecutive values. </td></tr>
    <tr><td class="paramname">__val</td><td>The value to find. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first iterator <code>i</code> in the range <code></code>[__first,__last-__count) such that <code>__binary_pred</code>(*(i+N),__val) is true for each <code>N</code> in the range <code></code>[0,__count), or <code>__last</code> if no such iterator exists.</dd></dl>
<p>Searches the range <code></code>[__first,__last) for <code>__count</code> consecutive elements for which the predicate returns true. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04898">4898</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>, and <a class="el" href="a01462_source.html#l00349">std::__search_n()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
